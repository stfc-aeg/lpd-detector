'''
Created on 18 Sep 2012

@author: Tim Nicholls, STFC Application Engineering Group
'''
from LpdFemTests.LpdFemClient import LpdFemClient, FemClientError
from LpdDeviceParameters import *

class LpdDevice(object):
    '''
    This class provides an application programming interface (API) to the LPD
    device, abstracting the details of the underlying FEM client transactions. 
    It implements simple commands (open, close, configure etc) to control the
    state of the LPD FEM, and provides parameter set/get methods for setting
    and retrieving parameters from the device.
    '''
    
    # FemClient connection default timeout
    defaultTimeout = 5
    
    # Error codes returned by this class.
    ERROR_OK                   = 0
    ERROR_FEM_CONNECT_FAILED   = 1000
    ERROR_FEM_CLIENT_EXCEPTION = 1001
    ERROR_PARAM_UNKNOWN        = 2000
    ERROR_PARAM_ILLEGAL_TYPE   = 2001
    ERROR_PARAM_ILLEGAL_VALUE  = 2002
    ERROR_PARAM_UNSET          = 2003
    ERROR_PARAM_VECTOR_LENGTH  = 2004
    ERROR_PARAM_NO_METHOD      = 2005

    def __init__(self, simulateFemClient=False):
        '''
        Constructor for LpdDevice
        
        @param simulateFemClient simulate FEM client connection by storing parameters locally and making dummy command calls
        '''
        
        self.simulateFemClient = simulateFemClient
        
        self.femClient = None
        self.errorString = ""
        
        # allowedParams is a dictionary of allowed parameters, with a camelCase key and data in the form of
        # a tuple that specifies everything in Sergei's 'Karabo Parameter Templates' document, namely:
        #
        # 'key' : ( type, displayed name, description, minimum possible value (or tuple of allowed values),
        #           max possible value (ignored if minimum is a tuple of possibles), default value,
        #           access type, assignment policy (True if optional, otherwise mandatory), 
        #           unit name, unit symbol )
        self.allowedParams = LpdDeviceParameters().get()
    
    def errorStringGet(self):
        '''
        Returns the last error string generated by the class
        '''
        return repr(self.errorString)
    
    def open(self, host, port, timeout=defaultTimeout):
        '''
        Opens a client connection to the LPD front-end module (FEM).
        
        @param host IP address of FEM as dotted quad format string
        @param port port of FEM to connect to (integer) 
        @param (optional) client timeout in seconds
        @return LpdDevice error code, ERROR_OK or ERROR_FEM_CONNECT_FAILED
        '''
        rc = LpdDevice.ERROR_OK
        if not self.simulateFemClient:
            try:
                
                self.femClient = LpdFemClient((host, port), timeout)

            except FemClientError as e:
                
                self.errorString = e.msg
                rc = LpdDevice.ERROR_FEM_CONNECT_FAILED
            
        return rc
    
    def close(self):
        '''
        Closes the client connection to the FEM. All subsequent transactions to
        the device will fail until open() is called again.
        '''
        if self.femClient:
            self.femClient.close()
            self.femClient = None
        
        return LpdDevice.ERROR_OK
    
    def configure(self):
        '''
        Commands the API to upload parameters to the FEM and ASICS and configure
        the system for running.
        '''
        
        return LpdDevice.ERROR_OK
    
    def start(self):
        '''
        Starts an acquisition sequence - prepares the FEM and ASICs to receive
        triggers and read out
        '''
        
        return LpdDevice.ERROR_OK
    
    def stop(self):
        '''
        Stops an acquisition sequence - stops readout of the FEM and ASICS. May be called
        once triggers have stopped to cleanly terminate acquisition, or during acquisition
        to abort cleanly
        '''
        
        return LpdDevice.ERROR_OK
        
    def paramSet(self, param, value, **kwargs):
        '''
        Sets a parameter
        '''
        
        rc = LpdDevice.ERROR_OK
        
        # Check if ASIC and/or pixel keyword arguments have been passed
        if 'asic' in kwargs:
            asic = kwargs['asic']
        else:
            asic = None
        if 'pixel' in kwargs:
            pixel = kwargs['pixel']
        else:
            pixel = None        
            
        # Check if parameter specified is allowed
        if param in self.allowedParams:
            
            # Test if parameter value can be converted to required type, otherwise trap as an illegal
            # value type. Handle vector parameters by converting in a list iterator and check that
            # the correct number of elements are provided
            try:
                if self.allowedParams[param].numElements > 1:                    
                    if len(value) != self.allowedParams[param].numElements:                        
                        rc = LpdDevice.ERROR_PARAM_VECTOR_LENGTH
                        self.errorString = 'Incorrect length for vector parameter %s specified: expected %d got %d' % \
                            (param, self.allowedParams[param].numElements, len(value))                            
                    else:
                        value = [self.allowedParams[param].type(element) for element in value]
                else:
                    value = self.allowedParams[param].type(value)

            except ValueError:
                rc = LpdDevice.ERROR_PARAM_ILLEGAL_TYPE
                self.errorString = 'Illegal value type for parameter %s specified: expected \'%s\' got \'%s\'' % \
                    (param , self.allowedParams[param].type.__name__, type(value).__name__)

            else:
                
                # Test if value(s) are within legal range. Promote scalar parameter values to a (temporary)
                # list to allow iteration
                if isinstance(value, list):
                    values = value
                else:
                    values = [value]
                    
                for entry in values:
                    
                    # If range was a list of possibilities, test that value exists in range, otherwise test
                    # against minimum and maximum values
                    if self.allowedParams[param].possVals != None:
                        if entry not in self.allowedParams[param].possVals:
                            rc = LpdDevice.ERROR_PARAM_ILLEGAL_VALUE
                            self.errorString = "Illegal value set %s for parameter %s" % (repr(entry), param)
                            break
                            
                    else:
                        if self.allowedParams[param].minValue != None and entry < self.allowedParams[param].minValue:
                            rc = LpdDevice.ERROR_PARAM_ILLEGAL_VALUE
                            self.errorString = "Illegal value set %s for parameter %s" % (repr(entry), param)
                            break
                        if self.allowedParams[param].maxValue != None and entry > self.allowedParams[param].maxValue:
                            rc = LpdDevice.ERROR_PARAM_ILLEGAL_VALUE
                            self.errorString = "Illegal value set %s for parameter %s" % (repr(entry), param)
                            break
                            
                # Only proceed if all values are legal
                if rc == LpdDevice.ERROR_OK:
                            
                    if not self.simulateFemClient:                    
                        
                        # Resolve the specified FEM client set function with the parameter. Trap the situation where
                        # the appropriate set method is not resolved - shouldn't happen if parameter definitions
                        # match the set/get method implementation
                        try:
                            setMethod  = getattr(self.femClient, '%sSet' % param)
                            
                        except AttributeError:
                            rc = LpdDevice.ERROR_PARAM_NO_METHOD
                            self.errorString = 'Failed to resolve client set method for for parameter %s' % param
                            
                        else:
                            
                            # Call the set method, trapping any FemClient exceptions that are generated 
                            try:
                                rc = setMethod(value, **kwargs)
                                
                            except FemClientError as e:
                                rc = LpdDevice.ERROR_FEM_CLIENT_EXCEPTION
                                self.errorString = 'FEM client exception on calling set method for parameter %s: %s' % \
                                    (param, e.msg)
                        
                    else:                    
                        
                        # Cache the value locally so subsequent gets return the same value
                        paramName = '%s_%s_%s' % (param, asic, pixel)
                        setattr(self, paramName, value)
                    
        else:
            rc = LpdDevice.ERROR_PARAM_UNKNOWN
        
        return rc
    
    def paramGet(self, param, **kwargs):
        '''
        Gets a parameter
        '''
        
        rc = LpdDevice.ERROR_OK
        value = None
        
 
        # Check if ASIC and/or pixel keyword arguments have been passed
        if 'asic' in kwargs:
            asic = kwargs['asic']
        else:
            asic = None
        if 'pixel' in kwargs:
            pixel = kwargs['pixel']
        else:
            pixel = None        

        if param in self.allowedParams:
            
            if not self.simulateFemClient:

                getMethod = getattr(self.femClient, '%sGet' % param)
                (rc, value) =  getMethod(**kwargs)

            else:
                try:
                    
                    paramName = '%s_%s_%s' % (param, asic, pixel)
                    value = getattr(self, paramName)
                    
                except AttributeError:
                    rc = LpdDevice.ERROR_PARAM_UNSET
                    self.errorString = 'Attempt to get unset parameter \'%s\'' % param
        else:
            rc = LpdDevice.ERROR_PARAM_UNKNOWN
            
        return (rc, value)
    

    def testCall(self, param, value, **kwargs):
        print param, ":", value
        for key in kwargs:
            print key, ":", kwargs[key]
