-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
i2c list of monitoring variables:
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Status:
	Low Voltage is on.
	High Voltage is on.
	HV setting 0 [0.00V]
Flags:
	Fault flag			No
	Fem Status		Trip	No
	External		Trip	No
	Overcurrent 	Trip	No
	Over Temperature	Trip	No
	Undertemperature	trip	Yes
Temperature readings:
	Temperature PSU Card	2.17V [2966]
	Temperature Sensor A	3.00V [4095]
	Temperature Sensor B	2.22V [3032]
	Temperature Sensor C	3.00V [4095]
	Temperature Sensor D	3.00V [4095]
	Temperature Sensor E	3.00V [4095]
	Temperature Sensor F	3.00V [4095]
	Temperature Sensor G	2.21V [3021]
	Temperature Sensor H	3.00V [4095]
Outputs:
	V FEM		5.00V [3411]	4.88A [1999]
	V Digital	1.22V [1668]	2.74mA [16]

	V Sensor A	2.55V [3474]	0.15A [60]
	V Sensor B	2.58V [3421]	2.04A [835]
	V Sensor C	2.55V [3478]	0.08A [31]
	V Sensor D	2.55V [3485]	0.15A [62]
	V Sensor E	2.55V [3480]	0.09A [36]
	V Sensor F	2.55V [3478]	0.07A [30]
	V Sensor G	2.58V [3522]	1.68A [688]
	V Sensor H	2.55V [3487]	0.08A [32]
	HV BIAS	1.61V [11]		0.00uA [0]


-=-=-=-=-=-=-=-=-
fem_asic_test.py:
-=-=-=-=-=-=-=-=-

        x10g_0 = {'src_mac' : self.mac_addr_to_uint64('62-00-00-00-00-01'),
                  'src_ip'  : self.ip_addr_to_uint32('192.168.7.2'),
                  'src_prt' : self.prt_addr_to_uint16('8'),
                  # Target PC:
                  'dst_mac' : self.mac_addr_to_uint64('00-07-43-10-61-88'),
                  'dst_ip'  : self.ip_addr_to_uint32('192.168.7.1'),
                  'dst_prt' : self.prt_addr_to_uint16('61649')}
        
        x10g_1 = {'src_mac' : self.mac_addr_to_uint64('62-00-00-00-00-01'),
                  'src_ip'  : self.ip_addr_to_uint32('192.168.8.2'),
                  'src_prt' : self.prt_addr_to_uint16('0000'),
                  'dst_mac' : self.mac_addr_to_uint64('00-07-43-06-31-A3'),  # in vhdl 10g 
                  'dst_ip'  : self.ip_addr_to_uint32('192.168.8.1'),
                  'dst_prt' : self.prt_addr_to_uint16('0000')}

        femHost = '192.168.2.2'
        femPort = 6969

        # enable sending reset to both ppc processors if = 1
        send_ppc_reset = 1
        
        # for new fast controls with optional dynamic vetos if = 1
        fast_ctrl_dynamic = 1
        
        # (Skip loading slow control block)
        # 0 = disable, 1 = enable filling slow control bram
        # ON Cold Start:
        setup_slow_control_bram = 1
        
        # send data via 10g udp block
        enable_10g = 1

        # Read 10g data either by packet or frames
        readout_mode = 'frame'
        
        # choose data source to 10g block 
        # 0 = llink frame generator
        # 1 = direct from asic
        # 2 = PPC
        data_source_to_10g = 1
        
        # 1 = dummy counting data from asic rx block
        # 0 = real data from asic
        asic_rx_counting_data = 0
        
        # 1 = single asic module
        # 2 = 2-Tile box
        asic_module_type = 2
        
        # for pseudo random frames from asic  (must also set asic_rx_counting_data = 0)
        asic_pseudo_random = 0

        # steer loading of brams for asic slow and fast configuration data
        # if data_source_to_10g is llink frame generator or PPC, set to 0
		# if data_source_to_10g is direct from asic, then asic_rx_counting_data
		#	decides: if 0 set to 1, L is set to 0
        load_asic_config_brams = 1

        # Nr (100 MHz) clock periods delay before start of asic data rx
        # tuned for various data runs to capture 1st data bit in stream
        # will be replaced later by signal from asic fast block to asic rx
		asic_rx_start_delay = 61

		# Number of local link frames to generate
		num_ll_frames = 1


		
		# trigger_type, 'a'=trigger local link frame generator,
		# 'all'=start asic seq, 'b'=trigger of asic rx block, 
		# 's'=trigger only the slow control IP block, 'f'=trigger the fast cmd block,
		# 'x'=trigger fast and asic rx (not slow)
		trigger_type = 'all'    # trigger FEM to load slow ctrl into ASICs    (Keep setup_slow_control_bram = 1)


        #--------------------------------------------------------------------
        # Options for configuring LPD ASICs 
        
        # Asic fast cmds 20 or 22 bits format
        fast_cmd_reg_size = 22
        
        # Asic Rx 128 bit channel enable masks (8*4*4 = 128)
		# mask_list determines which ASICs to enable (1 = enable, 0 = disable)
		#	Depends upon:
        mask_list = [0, 0, 0, 0]


        #set asic receiver readout size & frame allocation
        # valid settings with 16K FIFO
        # (more than 3 trigger overflows when going direct to 10 G link)
        #  2,2 = 3 triggers with 3 triggers per ll frame ; ie 1 frame
        #  1,1 = 2 triggers with 2 triggers per ll frame ; ie 1 frame
        # see labbook #19 p191  jac
        no_asic_cols         = 0   # set to zero means 1 time slice per trigger (because +1 added wherever no_asic_cols used)
        no_asic_cols_per_frm = 0   # set to zero means 1 time slice per trigger (because +1 added wherever no_asic_cols used)

        # Set up 10G UDP packet length, number & frame size
        eth_ifg = 0x00001000  # Ethernet Inter Frame Gap
        udp_pkt_len = 8000
        udp_pkt_num = 1
        
        # udp frame size in bytes should match data to be transferred
        # no_asic_cols = nr triggers ; Nb min nr triggers = 2  ?
        # 512 pixels per asic
        # 128 asics per fem
        # 2 bytes per pixel (after gain selection)
        # + 64 byte for asic rx header and trailer (each 8 x 32 bits) but removed by ll_rmv )
        udp_frm_sze = (no_asic_cols+1) * 512 * 128 * 2 + 0  # header and trailer removed by ll_rmv
        udp_in_buf_size = 2048*1024
        
        #  overrides to asic algorithm gain selection
        #  bits
        #  0000  normal gain selection     0
        #  1000  force select x100         8
        #  1001  force select x10          9
        #  1011  force select x1          11
        #  1111  force error condition ?  15
        asic_gain_override = 8
        
        # rob's udp packet headers : 0 to disable ; set bit 2 to enable, ie = 4 (decimal = 100b, binary) 
        # Disable for Matlab ; Enable for Python
        # Nb to enable need correct bit pattern
        # Nb this is not the same as asic rx header; Utilised by robs_udp_packet_header_10g()
        # Generate header with 10g data
        robs_udp_packet_hdr = 4


		# Setup the UDP IP blocks sending data via 10g udp block
        if (enable_10g == 1):
            
            #set up the UDP IP blocks
            x10g_0, x10g_1 = self.set_10g_structs_variables_te7burntoak()
            
            #set up the UDP IP blocks
            myLpdFemClient.fem_10g_udp_set_up_block0(udp_pkt_len, udp_frm_sze, eth_ifg)
            myLpdFemClient.fem_10g_udp_set_up_block1(udp_pkt_len, udp_frm_sze, eth_ifg)
            
            #set MAC, IP Port addresses
            myLpdFemClient.fem_10g_udp_net_set_up_block0(x10g_0)
            myLpdFemClient.fem_10g_udp_net_set_up_block1(x10g_1)
                
            myLpdFemClient.robs_udp_packet_header_10g(robs_udp_packet_hdr)
        
        #set up data generator 0
        ll_frm_gen_data_type=0


        #--------------------------------------------------------------------
        # configure the ASICs
		
		# Process slow data
		slow_ctrl_data, no_of_bits = myLpdFemClient.read_slow_ctrl_file('/u/ckd27546/workspace/lpd/src/LpdFemTests/SlowControlDefault-1A.txt')

		# Process fast data
		fileCmdSeq = LpdCommandSequenceParser('/u/ckd27546/workspace/lpd/src/LpdCommandSequence/fast_readout_replacement_commands.xml', fromFile=True)
		fast_cmd_data = fileCmdSeq.encode()
	
		no_of_words = fileCmdSeq.getTotalNumberWords()
		no_of_nops = fileCmdSeq.getTotalNumberNops()


        #--------------------------------------------------------------------

        # create an array of uint32 to hold the data frame
        data_size = udp_frm_sze/2
        dudp = [0] * data_size
        packet_size = udp_pkt_len/2


